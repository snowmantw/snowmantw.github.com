<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Snowmantw's Blog]]></title>
  <link href="http://snowmantw.github.com/atom.xml" rel="self"/>
  <link href="http://snowmantw.github.com/"/>
  <updated>2012-09-19T20:57:56+08:00</updated>
  <id>http://snowmantw.github.com/</id>
  <author>
    <name><![CDATA[snowmantw]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Note: Cmake Learning #1]]></title>
    <link href="http://snowmantw.github.com/blog/2012/09/19/note-cmake-learning-number-1/"/>
    <updated>2012-09-19T20:32:00+08:00</updated>
    <id>http://snowmantw.github.com/blog/2012/09/19/note-cmake-learning-number-1</id>
    <content type="html"><![CDATA[<ul>
<li>參考資源

<ul>
<li><a href="http://zh.wikibooks.org/wiki/CMake_%E5%85%A5%E9%96%80">Cmake 入門</a></li>
<li><a href="http://www.cmake.org/cmake/help/v2.8.8/cmake.html#section_Commands">Cmake 官方網站：命令列表</a></li>
</ul>
</li>
</ul>


<hr />

<ul>
<li>如果要尋找系統中有沒有特定函式庫，首先要確定有該函式庫的模組。可用 <code>cmake --help-module-list</code> 協助尋找是否該模組存在</li>
<li>如果有該模組，可以用 <code>find_package</code> 命令去找。注意該命令給定的名字必須符合前述搜尋模組給的名字，而不是系統中套件名稱。例如</li>
</ul>


<pre>
     # Find GLUT package in system. 
     # Not system package name like "freeglut3-dev".
     find_package (GLUT REQUIRED) 
</pre>


<ul>
<li>如果要作不符合條件即中斷 Cmake 執行，可以使用 <code>message(FATAL_ERROR "&lt;message&gt;")</code> 的方式印出錯誤後中止執行。
例如前述尋找系統套件，找不到就可以用這種方式報錯離開</li>
</ul>


<hr />

<ul>
<li><code>target_link_library</code> 是該 Cmake 所針對的編譯單元，需要連結哪些函式庫</li>
<li><code>add_library</code> 則是把該編譯單元包成函式庫，兩者目的相關方向相反</li>
<li><code>target_link_library</code> 可以指定編譯器連結參數，例如</li>
</ul>


<pre>
     # Require compiler compiling with these arguments.
     target_link_libraries(CGHW1 -lGL -lglut -lGLU)
</pre>


<ul>
<li>這邊的連結參數會影響產生的 Makefile 中所下參數，所以是必要的</li>
</ul>


<hr />

<ul>
<li>Cmake 2.8 還是需要在 <code>else</code> 這個關鍵字後面接上條件的樣子。不能如前面那樣省略，而是必需變成 <code>else(&lt;condition&gt;)</code></li>
<li>推薦使用所謂 &#8220;Out-of-source Build&#8221; ，將建置目錄與原始碼目錄分開</li>
<li>Cmake 執行時指定目錄，會自動找尋其中是否有 CMakeLists.txt 並利用執行</li>
<li>Cmake 範例的結構中，看起來是每個模組或其他編譯單元的目錄中都各有一個 CMakeLists.txt ，整個專案再一個。
例如「Cmake 入門」中的<a href="http://zh.wikibooks.org/wiki/CMake_%E5%85%A5%E9%96%80/%E5%BB%BA%E7%BD%AE%E8%88%87%E9%80%A3%E7%B5%90%E7%A8%8B%E5%BC%8F%E5%BA%AB">範例</a>:</li>
</ul>


<pre>
    lib1/
        src/
            app/
                CMakeLists.txt
                main.c
            calc/
                CMakeLists.txt
                calc.c
                calc.h
    CMakeLists.txt
</pre>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Note: Yesod Web Framework #1]]></title>
    <link href="http://snowmantw.github.com/blog/2012/09/19/note-yesod-web-framework-1/"/>
    <updated>2012-09-19T13:19:00+08:00</updated>
    <id>http://snowmantw.github.com/blog/2012/09/19/note-yesod-web-framework-1</id>
    <content type="html"><![CDATA[<h2>Foundation.hs</h2>

<ul>
<li>Foundation.hs 提供載入資源，以及變成內部資源參照值的函式。</li>
<li>該檔案中有分為 Route 、基本核心、儲存機制、認證等界面可以自訂，以此定義出應用本身所需要的各資源模組</li>
<li>Route 是呼叫特定函式，載入 Route 檔案並建立出 AppRoute</li>
<li>基本核心包括 Session 後端組件、如何渲染頁面 Widget 、Static 檔案設定等</li>
<li>Widget 應該說是子頁面，最終要併到 default-layout-wrapper 這種 Wrapper 的樣板檔中</li>
<li>RenderMessage 是用來把一些預設訊息渲染出來，包括處理 i18n 之類議題的設定 Type Class</li>
</ul>


<h2>Application.hs</h2>

<ul>
<li>此檔案將建立整個應用</li>
<li>Handler 也是註冊在這邊。Cabal 檔裡也要記得增加</li>
<li>其中 makeFoundation 與 makeApplication 將會分別建立資源參照與 WAI 應用，而後者會相依前者。</li>
<li>makeApplication 另外還會被 main 函式所直接呼叫</li>
<li>mkYesodDispatch 會建立應用實體，是繼 mkYesodData 所建立好資料後，繼續接手的程式。這個函式也是實際上會建立 YesodSite 的函式。</li>
<li>從目前看到的只能說 mkYesodDispatch 建立網站本身，makeApplication 建立整個 WAI 應用。( WAI: Web Server 與 Application 的介面<a href="http://www.yesodweb.com/book/web-application-interface" title="Yesod Official Site">^1</a> )</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Note: Computer Graphics #1]]></title>
    <link href="http://snowmantw.github.com/blog/2012/09/19/note-computer-graphics-number-1/"/>
    <updated>2012-09-19T13:11:00+08:00</updated>
    <id>http://snowmantw.github.com/blog/2012/09/19/note-computer-graphics-number-1</id>
    <content type="html"><![CDATA[<ul>
<li>Shading 是指在面與線的基礎上增加了光線與材質的交互作用層</li>
<li>Texture 則是加在表面呈現出材質的效果</li>
<li>Framebuffer 記憶體將儲存運算後的資料，然後顯示器朝之要這些資料並畫出來</li>
<li>Framebuffer 如何更新是重點之一</li>
<li>Model-Rendering-Animation 是三個領域</li>
<li>Pixel 對記憶體就是位元組。比如 4 Bytes 對應到 32 萬色的一個像素</li>
<li>如果沒有 Shading ，每個面都會同色同光。加上去後才有光影立體的感覺</li>
<li>Shadow 與 Reflection 則是後面的工作</li>
</ul>


<hr />

<ul>
<li>Rendering Pipline ：平行處理</li>
<li>轉換觀點：Transformation ，去以相機為準變換整個影像</li>
<li>Transformer &#8211;> Clipper &#8211;> Projector &#8211;> Rasterizer &#8211;> Pixels</li>
<li>Transformer 是幾何轉換</li>
<li>Clipper 把不在視覺中的物體遮掉不顯示</li>
<li>Rasterizer 從幾何轉換成像素觀點（從平面頂點變為描述哪些像素要被填滿）</li>
<li>Shading 還在後面。不過為了效率，會在過程中作</li>
</ul>


<hr />

<ul>
<li>Global Illumination ：全環境中的光線軌跡。包括散射之類的議題。</li>
<li>物理光學以外，還有一種是繪圖風格的渲染方式</li>
</ul>


<hr />

<ul>
<li>課程會把 OpenGL 核心功能實做一次</li>
<li>根據老師的提醒，OpenGL 矩陣存到記憶體順序是 Column Major 。代表順序是從左上開始往下數，最後面是最右下。因此</li>
</ul>


<pre>
    M[16] == {0,1,2,3,4,5,6,7}

    [ 0  4
      1  5
      2  6
      3  7 ]
</pre>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[An Introduction to Haskell Components]]></title>
    <link href="http://snowmantw.github.com/blog/2012/07/14/an-introduction-to-haskell-components/"/>
    <updated>2012-07-14T09:10:00+08:00</updated>
    <id>http://snowmantw.github.com/blog/2012/07/14/an-introduction-to-haskell-components</id>
    <content type="html"><![CDATA[<p>這是我於 <a href="http://registrano.com/events/fpug-sig-1">Functional Programming SIG #1</a> 中介紹 <a href="http://www.haskell.org/haskellwiki/Typeclassopedia#Monad">Monad</a> 、 <a href="http://www.haskell.org/haskellwiki/Typeclassopedia#Arrow">Arrow</a> 與
其他 Haskell 運算元件的簡報。分為 <a href="https://docs.google.com/open?id=0BzqwG7n2gs71blE5V2pzR29WUDQ">PDF</a> 與 <a href="https://docs.google.com/open?id=0BzqwG7n2gs71ek9LTDBPczZPSjA">MS 2007</a> 檔案格式，採用 <a href="http://creativecommons.org/licenses/by-nc-sa/2.5/tw/">CC BY-NC-SA</a> 方式授權。</p>

<iframe src="https://docs.google.com/file/d/0BzqwG7n2gs71ek9LTDBPczZPSjA/preview" width="640" height="480"></iframe>




<br/>


<p>最近正在了解 <a href="http://www.haskell.org/haskellwiki/Functional_Reactive_Programming">Functional Reactive Programming</a> ，過程中很多細節要思考。
希望了解後可以更好的開發 Haskell 應用程式。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FWD: I Feel Sorry For Computer Science Departments]]></title>
    <link href="http://snowmantw.github.com/blog/2012/06/23/fwd-i-feel-sorry-for-computer-science-departments/"/>
    <updated>2012-06-23T17:13:00+08:00</updated>
    <id>http://snowmantw.github.com/blog/2012/06/23/fwd-i-feel-sorry-for-computer-science-departments</id>
    <content type="html"><![CDATA[<p><a href="http://programming-puzzler.blogspot.co.uk/2012/06/i-feel-sorry-for-computer.html">這篇文章</a>講述了作者 <a href="http://www.blogger.com/profile/05992502488191304160">Mark Engelberg</a> 覺得目前 (美國？) 的 CS 教育，遠不夠讓一個人從四年的大學教育去專精於 CS 領域。</p>

<p><em>重點摘錄：CS 教育應該要從大學以前就開始，因為四年遠不夠讓人專精於 CS 領域。尤其是大學以前的數學教育，
都強調於微積分相關的學習，這應該要被扭轉成教導離散數學為重心。另外也要提供學生及早開始接觸 programming 的機會。</em></p>

<pre><code>Colleges have 4 years to try to instill some meaningful level of 
expertise in students, but that's simply not enough time.
</code></pre>

<p>這個問題對 CS 系所來講是嚴肅的抉擇問題：到底課程要專注在我們認為一個 CS 人應該有修為這個遠景上，
還是教學專注在職業會用到的技能上？</p>

<pre><code>... do we focus on foundational skills and the big picture of 
what computer science is all about, or do we focus on technical training to 
try to produce graduates who have skills with immediate appeal to companies? 
</code></pre>

<p>作者還提到公司為何會對學校失望：他們希望雇用的是剛好可以勝任該職務技能的人。但因為這個目標無法達成，
所以它們轉找最「聰明」的人，也就是可以最快上手的人。但對 CS 這門學科而言，類似於學位這樣的指標也很難切合這樣的要求。
雖然畢業名校這點，對於它們想要尋找有天賦之人比較有幫助。</p>

<pre><code>More often than not, the knowledge gained from a CS education is 
viewed by companies as being so insufficient as to be almost irrelevant – nevertheless, 
graduating from a well-known school can be seen as a kind of proxy for the kind of 
drive and innate smarts they really are looking for.
</code></pre>

<p>作者又講到其他系所應該也會有這類問題。但在這點上， CS 到底有何不同？作者認為最關鍵的一點在於
其他學科的知識多少從小學就開始接觸，但 CS 所要學習的卻缺席於大學以前的教育中。</p>

<pre><code>How do other departments solve this problem? 

Well, many domains are able to leverage the significant number of years
that students have already invested in grade school in English, math, and science.
</code></pre>

<p>以數學為例，很不幸的是，作者認為 CS 最重要的是離散數學，但這卻與大學以前的教育方針相反。
作者還提到學習微積分其實與 CS 最迫切需要的數學是最無關的科目。而對大學以前的教育卻往往強調在微積分相關的學習上。</p>

<pre><code>Calculus, the pinnacle of grade school math education as it is currently structured, 
is the least relevant type of math for computer scientists. 

Computer scientists need a strong background in Discrete Math and these topics are poorly 
covered in grade school, if at all.
</code></pre>

<p>同時在作者心中，即使在教育很好的地區，對於讓學生提早接觸 programming 的機會也是非常貧乏的</p>

<pre><code>... most places probably have it much worse in terms of providing 
kids with early exposure to programming.
</code></pre>

<p>要解決這個問題，很明顯的，只有提供更長遠的解決方式。這包括延長大學的畢業年限，或是相反，
讓程式設計相關的課程提早深入大學以下的學制中。</p>

<pre><code>Once the problem has been laid bare like this – four years provides insufficient 
preparation for a career in computer science – it is obvious that there are only 
a couple long-term solutions.

One possibility is to extend the duration of CS education, 
another possibility is to incorporate more CS topics and exposure to 
programming into the grade school curriculum.
</code></pre>

<p>作者也提到為何要迫切提高程式設計的專精度：他認為程式設計將是社會上很重要的一種基礎技能，提高整體程式水平將可以使社會受益</p>

<pre><code>I think a strong case can be made that our society would benefit from more CS in grade school
</code></pre>

<p>並且在 TED 大會上，另一位人士也提到了提高離散數學的重要性</p>

<pre><code>Arthur Benjamin makes the case in his TED talk that discrete math (logic, statistics, etc.) 
is far more relevant to most walks of life than, say, calculus.
</code></pre>

<p>不過作者最後講了，即使我們都做到了這點，另一個更難的問題：尋找更多夠格的老師，要怎樣解決？</p>

<pre><code>... how do you go about finding and recruiting qualified teachers? 
</code></pre>

<p>我想對於老是喊著資訊國力之類的政府，應該要抉擇：軟體產業需要更多的投入與堅持。
也許我們應該減少專注於，或說實在一點是排擠於大學、高中課程中非程式軟體相關的科目。
除非我們學制也要開始建構真正的技術類學習，分於普通學習之途。</p>

<p>然而更重要的應該是並認清硬體方式的生產有其極限，
而軟體產業可能是未來一大重點。然而軟體產業絕非如硬體那樣砸錢砸人數，以及其他資本就可以搞定。
畢竟大規模的「擴產」對軟體而言可能反是阻力。加上軟體的開發牽涉到台灣企業與政府最缺乏的耐心與人本思維，
要成熟可能是忍受虧損或無收入一段長時間後才能看到成果。
且對軟體設計者不能像硬體那樣靠著工業製造甚至軍隊的管理方式對待。</p>

<p>這些種種可能都是習慣於生產製造思維的政府與工業會被迫殘酷的轉型，或是殘酷的死亡之絆腳石。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reading: Applying hardware testing concepts to software]]></title>
    <link href="http://snowmantw.github.com/blog/2012/06/22/reading-applying-hardware-testing-concepts-to-software/"/>
    <updated>2012-06-22T22:13:00+08:00</updated>
    <id>http://snowmantw.github.com/blog/2012/06/22/reading-applying-hardware-testing-concepts-to-software</id>
    <content type="html"><![CDATA[<p><a href="http://www.dodgycoder.net/2012/06/applying-hardware-testing-concepts-to.html">這篇文章</a>講述作者 <a href="http://www.blogger.com/profile/14418022725678218844">Dodgy_Coder</a> 自己測試 GUI 程式的經驗，
他覺得軟體的測試在時間長度的概念上可以借鑒硬體的測試概念分三種時間相關的測試概念</p>

<ol>
<li>短：功能性測試，包括 Unit Testing 與 Integration Testing。這邊可以除去絕大部分的問題。</li>
<li>中：用來測試與減少隨機錯誤。隨機錯誤不太可能完全清除，但可以儘量減少、消除到機率合乎標準</li>
<li>長：將軟體執行到超乎一般時間的長，用來測試諸如記憶體洩漏、效能下降等問題。</li>
</ol>


<p>作者自己的經驗是他的程式一般只會開半小時，他故意開著兩個小時作測試，
然後在第一個小時時就發現了記憶體洩漏與效能下降的問題，並修正之。</p>

<p>其他概念可以上作者文章看；他那張引自 <a href="http://upload.wikimedia.org/wikipedia/commons/6/6e/Bathtub_curve.jpg">wikipedia</a> 的圖還蠻好的</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/6/6e/Bathtub_curve.jpg" alt="Bathub curve about testing" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Helloween Documents Re-reading]]></title>
    <link href="http://snowmantw.github.com/blog/2012/06/22/helloween-documents-re-reading/"/>
    <updated>2012-06-22T21:31:00+08:00</updated>
    <id>http://snowmantw.github.com/blog/2012/06/22/helloween-documents-re-reading</id>
    <content type="html"><![CDATA[<p>這篇算是舊文章了。所謂的萬聖節文件，是在 <a href="http://reocities.com/heartland/village/9328/halloween.html">1998 年時從微軟內部洩漏的一份文件</a>，其中</p>

<pre><code>披漏了微軟總部Redmond, 在未來預備對付Linux及開放性原始碼軟體的策略, 
消息來源希望保密. 我為這份文件在萬聖節其間做了些註解
</code></pre>

<p>這邊所謂的「我」指的是 Eric S. Raymond ，Open Source 界的大老。</p>

<p>這份文件揭露了封閉的微軟是如何既錯誤又正確的看待 OSS ，以及其如何「準備」削弱與摧毀 OSS。</p>

<p>讓我感慨的是過了這麼多年，OSS 還是受到許許多多的威脅。而今更享有自由的 OSS 開發者與受益的使用者，
是否真的重視如今的自由呢？看 Apple 那樣的封閉開發者市場，developer 與 user 卻不是很在意。又像 Facebook ，
本身就是一個封閉的巨大論壇，開發與使用者一樣不在意。（連搜尋也無法搜到資訊！這也是我厭惡的地方。
更糟糕的是現在有些服務會認為每個人都會有，因此只提供 Facebook 服務的公開資訊。
相較之下網頁與 Mail 至少是公開的，我可以用 Gmail/Hotmail/學校信箱/自己架&#8230;）</p>

<p>身為一個學習者，受益於 OSS 界眾多的時候，也應該思考像這樣的理念之爭，尤其是會真槍實彈影響到每個人的自由時，
自己該怎樣思考、怎麼去作。又回來看看，各資訊學系的同學是否又真正了解這些重要的問題？</p>

<p>參考文章</p>

<ul>
<li><a href="http://www.gnu.org/philosophy/free-software-for-freedom.html">自由軟體，不只是開放源碼</a> ：Open Source != Free Software != Freesoftware</li>
<li><a href="http://inspire.twgg.org/c/internet/trends/comparison-of-five-kinds-of-standard-open-source-license-bsd-apache-gpl-lgpl-mit.html">五種開源授權規範的比較</a> (BSD, Apache, GPL, LGPL, MIT)</li>
<li><a href="http://easylearn.bhes.ntpc.edu.tw/high/xvid_history.htm">Xvid 的歷史與特點</a>：divx 如何「剽竊」OSS 開發者的心血，以及使用自由而非僅僅是 Open Source 許可證有多重要</li>
<li><a href="http://blog.tenyi.com/2008/04/blog-post_23.html">東芝微軟戰記</a>：一篇很有名的文章，講述作者為了退掉微軟稅花了多大苦工 ( 轉自鳥毅 Blog )</li>
</ul>


<p>最後引用 <a href="http://en.wikipedia.org/wiki/Martin_Niem%C3%B6ller">Martin Niemöller</a> 牧師很有名的一段懺悔文作結</p>

<p>「起初他們追殺共產主義者」</p>

<p>當納粹追殺共產主義者<br/>
我保持沉默<br/>
——我不是共產主義者<br/>
當他們追殺社會民主主義者<br/>
我保持沉默<br/>
——我不是社會民主主義者<br/>
當他們追殺工會成員<br/>
我沒站出來說話<br/>
——我不是工會成員<br/>
當他們追殺猶太人<br/>
我保持沉默<br/>
——我不是猶太人<br/>
當他們要追殺我<br/>
再也沒有人為我說話了<br/></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Yet Another Coder]]></title>
    <link href="http://snowmantw.github.com/blog/2012/06/17/yet-another-coder/"/>
    <updated>2012-06-17T15:07:00+08:00</updated>
    <id>http://snowmantw.github.com/blog/2012/06/17/yet-another-coder</id>
    <content type="html"><![CDATA[<h2>Profile</h2>

<h3>snowmantw ( Greg Weng )</h3>

<pre><code>✝  Christian
:  Vimmer
/  Linux User
λ  Haskell Learner
G  Self-Studier
$  Javascript Developer
@  snowmantw at gmail.com  
✎  Literure Fan  
♪  Classical Music Fan
✍  Master's Degree Student → Dept. of Computer Science, NCCU  
台  Taiwanese
</code></pre>

<hr />

<h2>Public Projects:</h2>

<ul>
<li><a href="https://github.com/snowmantw/FunTang">FunTang</a>  : functional features added CoffeeScript</li>
<li><a href="https://github.com/snowmantw/Fluorine">Fluorine</a> : Arrow in Javascript with fully event-driven features</li>
</ul>


<hr />

<h2>Favorite Books:</h2>

<ul>
<li>Nineteen Eighty-Four by George Orwell</li>
<li>A Song of Ice and Fire by George R. R. Martin</li>
<li>The Chronicles of Narnia by C.S. Lewis</li>
<li>銀河英雄伝説 by 田中芳樹</li>
<li>萬曆十五年 by 黃仁宇</li>
<li>翻譯者 by 賴香吟 ( 中篇小說 )</li>
<li>銃夢 by 木城ゆきと</li>
<li>風の谷のナウシカ by 宮崎駿</li>
</ul>

]]></content>
  </entry>
  
</feed>
